input {
  twitter {
      consumer_key => "<YOUR-KEY>"
      consumer_secret => "<YOUR-KEY>"
      oauth_token => "<YOUR-KEY>"
      oauth_token_secret => "<YOUR-KEY>"
      keywords => [ "random", "word"]
      full_tweet => true
      type => "tweet"
  }
}
filter {
    mutate {
       remove_field => ["contributors", "current_user_retweet", "favorited",
       "filter_level", "geo", "id", "possibly_sensitive", "quoted_status_id",
       "quoted_status_id_str", "quoted_status", "scopes", "retweeted", "source",
       "truncated", "withheld_copyright", "withheld_in_countries",
       "withheld_scope"]
    }
    if([retweeted_status]) {
       mutate {
          add_field => {
             "tweet_content" => "%{[retweeted_status][text]}"
             "is_a_retweet" => true
             "original_tweet_id" => "%{[retweeted_status][id_str]}"
             "original_author_id" => "%{[retweeted_status][user][id_str]}"
             "original_author_pseudo" => "%{[retweeted_status][user][screen_name]}"
             "original_author_name" => "%{[retweeted_status][user][name]}"
             "is_original_author_verified" => "%{[retweeted_status][user][verified]}"
             "original_author_followers_count" => "%{[retweeted_status][user][followers_count]}"
             "original_author_friends_count" => "%{[retweeted_status][user][friends_count]}"
             "is_original_author_protected" => "%{[retweeted_status][user][protected]}"
          }
       }
       date {
          match => ["[retweeted_status][created_at]", "EEE MMM dd HH:mm:ss Z yyyy"]
          target => "original_tweet_created_at"
       }
       date {
          match => [ "[retweeted_status][user][created_at]", "EEE MMM dd HH:mm:ss Z yyyy" ]
          target => "original_author_account_creation"
       }
       ruby {
         code => '
           event.set("original_retweet_count", event.get("[retweeted_status][retweet_count]"))
           event.set("favorite_count", event.get("[retweeted_status][favorite_count]"))
           event.set("tweet_coordinates", event.get("[retweeted_status][coordinates][coordinates]")) if !event.get("[retweeted_status][coordinates][coordinates]").nil?
           event.set("original_reply_to_tweet", event.get("[retweeted_status][in_reply_to_status_id_str]")) if !event.get("[retweeted_status][in_reply_to_status_id_str]").nil?
           event.set("original_reply_to_user_id", event.get("[retweeted_status][in_reply_to_user_id_str]")) if !event.get("[retweeted_status][in_reply_to_user_id_str]").nil?
           event.set("original_reply_to_pseudo", event.get("[retweeted_status][in_reply_to_screen_name]")) if !event.get("[retweeted_status][in_reply_to_screen_name]").nil?
           event.set("original_author_location", event.get("[retweeted_status][user][location]")) if event.get("[retweeted_status][user][location]")
           event.set("original_author_description", event.get("[retweeted_status][user][description]")) if event.get("[retweeted_status][user][description]")
           event.set("original_author_lang", event.get("[retweeted_status][user][lang]")) if event.get("[retweeted_status][user][lang]")
         '
       }
    }
    else{
       mutate {
         add_field => {
            "tweet_content" => "%{[text]}"
            "is_a_retweet" => false
         }
       }
    }
    date {
       match => ["[created_at]", "EEE MMM dd HH:mm:ss Z yyyy"]
       target => "tweet_created_at"
    }
    date {
        match => [ "[user][created_at]", "EEE MMM dd HH:mm:ss Z yyyy" ]
        target => "author_account_creation"
    }
    ruby {
      code => '
        hashtags = []
        user_mentions_id = []
        user_mentions_pseudo = []
        urls = []
        event.get("[entities][hashtags]").each do |hashtag|
          hashtags << hashtag["text"].downcase
        end
        event.get("[entities][user_mentions]").each do |user_mention|
          user_mentions_id << user_mention["id_str"]
          user_mentions_pseudo << user_mention["screen_name"]
        end
        event.get("[entities][urls]").each do |url|
          urls << url["expanded_url"]
        end
        event.set("hashtags", hashtags) if hashtags.any?
        event.set("user_mentions_id", user_mentions_id) if user_mentions_id.any?
        event.set("user_mentions_pseudo", user_mentions_pseudo) if user_mentions_pseudo.any?
        event.set("urls", urls) if urls.any?
        event.set("tweet_lang", event.get("[lang]")) if event.get("[lang]")
        event.set("author_location", event.get("[user][location]")) if event.get("[user][location]")
        event.set("author_description", event.get("[user][description]")) if event.get("[user][description]")
        event.set("author_lang", event.get("[user][lang]")) if event.get("[user][lang]")
        event.set("tweet_coordinates", event.get("[coordinates][coordinates]")) if !event.get("[coordinates][coordinates]").nil?
        event.set("reply_to_tweet", event.get("[in_reply_to_status_id_str]")) if !event.get("[in_reply_to_status_id_str]").nil?
        event.set("reply_to_user_id", event.get("[in_reply_to_user_id_str]")) if !event.get("[in_reply_to_user_id_str]").nil?
        event.set("reply_to_pseudo", event.get("[in_reply_to_screen_name]")) if !event.get("[in_reply_to_screen_name]").nil?

      '
    }
    mutate {
       add_field => {
         "tweet_id" =>  "%{[id_str]}"
         "author_id" => "%{[user][id_str]}"
         "author_pseudo" => "%{[user][screen_name]}"
         "author_name" => "%{[user][name]}"
         "is_author_verified" => "%{[user][verified]}"
         "author_followers_count" => "%{[user][followers_count]}"
         "author_friends_count" => "%{[user][friends_count]}"
         "is_author_protected" => "%{[user][protected]}"
       }
    }
    mutate {
       convert => {
          "original_author_followers_count" => "integer"
          "original_author_friends_count" => "integer"
          "author_followers_count" => "integer"
          "author_friends_count" => "integer"
          "is_author_protected" => "boolean"
          "is_author_verified" => "boolean"
          "is_a_retweet" => "boolean"
          "is_original_author_verified" => "boolean"
          "is_original_author_protected" => "boolean"
       }
       lowercase => ["tweet_content"]
    }
    mutate {
       remove_field => ["retweeted_status", "text", "truncated", "created_at",
       "user", "@timestamp", "@version", "type", "timestamp_ms", "is_quote_status",
       "extended_entities", "lang", "extended_tweet", "entities", "in_reply_to_screen_name",
       "coordinates", "in_reply_to_status_id_str", "in_reply_to_status_id",
       "place", "display_text_range", "in_reply_to_user_id_str", "in_reply_to_user_id",
       "id_str"]
    }
}
output {
  elasticsearch {
    hosts => [ "localhost:9200" ]
    index => "twitter"
    document_type => "tweet"
    document_id => "%{[tweet_id]}"
  }
}
